---
layout: post
title: Java面试题收集
tags: [面试]
categories: [面试]
---



[toc]



## 多线程相关

### 1. 并行和并发有什么区别？

并行和串行

通俗来说，并发是一个人在做多件事，并行是多个人同时在做多件事。
只不过并发的时候，CPU高速切换线程，表面上看起来是在同时做多件事。

常说的“多线程”一般是指在同一个进程内，多个线程并发执行。

### 2. 线程和进程的区别？
进程是操作系统资源分配的基本单位，而线程是系统调度的基本单位。
线程是操作系统最小调度单位，是操作系统分配处理器时间资源的基本单位。
进程可以包含多个线程、线程共享进程内存空间

| 进程占有的资源                                               | 线程占有的资源                         |
| ------------------------------------------------------------ | -------------------------------------- |
| 地址空间<br/>全局变量<br/>打开的文件<br/>子进程<br/>信号量<br/>账户信息 | 栈<br />寄存器<br/>状态<br/>程序计数器 |



### 3. 守护线程是什么？
是服务于其他线程的服务线程，一直服务到jvm停止，最典型的应用就是GC线程

其他线程叫做用户线程，就是应用程序里的线程

4种

1. 继承Thread
2. 实现Runnable run
3. 实现Callable call
4. 线程池创建

### 5. 说一下 runnable 和 callable 有什么区别？

相同点：

都是接口，都可以创建线程，都需要 start方法启动线程

不同点：

| runnale        | callable             |
| -------------- | -------------------- |
| 实现run接口    | 实现call接口         |
| 不抛检查型异常 | 会抛异常             |
| java.lang      | java.util.concurrent |
| 不返回执行接口 | 可以返回执行结果     |





### 6. 线程有哪些状态？

创建

就绪：T.start()之后就进入到就绪状态，拿到执行权（锁），等待os调度

运行：os调度

阻塞：T.sleep()、T2.join()、

死亡：run()结束

### 7. sleep() 和 wait() 有什么区别？



| sleep                                                        | wait                                                         |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| Thread类的静态方法，                                         | Object的方法                                                 |
| 不释放资源（锁），其他线程不能抢占资源，sleep时间一到，自动进入就绪状态，等待os调度 | 释放资源（锁），其他线程可以抢占资源，需notify才能进入就绪状态 |
| sleep抛异常                                                  | wait不抛异常                                                 |
| sleep可以在任何地方调用                                      | wait只能在同步方法和同步代码块中使用                         |





### 8. notify()和 notifyAll()有什么区别？
notify唤醒一个线程，

notifyAll唤醒全部线程

### 9. 线程的 run()和 start()有什么区别？
run就是普通方法，

start才会使线程进入就绪状态

### 10. 创建线程池有哪几种方式？
1. 创建数量不定的线程池-`newCachedThreadPool`

   可缓存，可灵活回收空闲线程，若无可回收，则创建新的线程
   
2. 创建数量固定的线程池-`newFixedThreadPool`

   可控制最大并发数，超出的线程会在队列中等待
   
3. 创建单线程的线程池-`newSingleThreadExecutor`

   只会用一个线程来执行任务，按指定顺序（FIFO、LIFO、优先级）执行
   
4. 创建定时执行的线程池-`newScheduledThreadPool`

   支持定时及周期性执行任务



#### 使用`Executors`创建：

```java
// 创建数量不固定的线程池
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
// 创建数量固定的线程池
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
// 创建单线程的线程池
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
// 创建定时执行的线程池
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);

```



#### 使用`Executors`的弊端

1. `newFixedThreadPool`和`newSingleThreadExecutor` 允许的请求队列长度为`Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致OOM
2. `newCachedThreadPool`允许创建的线程数量为`Integer.MAX_VALUE`，可能会大量创建线程，从而导致OOM



通过查看源码，发现底层都是`ThreadPoolExecutor`创建的。

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

参数：

1. `corePoolSize` - 线程池核心池的大小
2. `maximumPoolSize`-线程池的最大线程数
3. `keepAliveTime`-当线程数大于核心池大小的时候，这个时间是多余的空闲线程等待任务的时间，超过这个时间，线程终止
4. `unit` - keepAliveTime 的时间单位
5. `workQueue` - 用来储存等待执行任务的队列，只会存储调用submit或者execute方法的线程
   1. `ArrayBlockingQueue` ：一个由数组结构组成的有界阻塞队列。
   2. `LinkedBlockingQueue` ：一个由链表结构组成的有界阻塞队列。
   3. `PriorityBlockingQueue` ：一个支持优先级排序的无界阻塞队列。
   4. `DelayQueue`： 一个使用优先级队列实现的无界阻塞队列。
   5. `SynchronousQueue`： 一个不存储元素的阻塞队列。
   6. `LinkedTransferQueue`： 一个由链表结构组成的无界阻塞队列。
   7. `LinkedBlockingDeque`： 一个由链表结构组成的双向阻塞队列。
6. `threadFactory` - 线程工厂，创建线程用
7. `handler` - 拒绝策略，由于达到线程边界和容量而阻止执行时要使用的处理程序
   1. `ThreadPoolExecutor.AbortPolicy`: 丢弃任务并抛出`RejectedExecutionException`异常。 (默认)
   2. `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常。
   3. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此程）
   4. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务

#### 使用`ThreadPoolExecutor`创建

```java
// newCachedThreadPool 源码
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
60L, TimeUnit.SECONDS,
new SynchronousQueue<Runnable>());

// newFixedThreadPool 源码
ThreadPoolExecutor threadPoolExecutor1 = new ThreadPoolExecutor(5, 5,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue<Runnable>());


// newSingleThreadExecutor源码
// 封装成FinalizableDelegatedExecutorService
ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(1, 1,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue<Runnable>());

// newScheduledThreadPool 源码
ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
```

- 无返回值的任务使用`execute(Runnable)`
- 有返回值的任务使用`submit(Runnable)`



Spring中配置

```xml

<!-- spring thread pool executor -->
<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <!-- 线程池维护线程的最少数量 -->
    <property name="corePoolSize" value="10"/>
    <!-- 允许的空闲时间 -->
    <property name="keepAliveSeconds" value="60"/>
    <!-- 线程池维护线程的最大数量 -->
    <property name="maxPoolSize" value="10"/>
    <!-- 缓存队列 -->
    <property name="queueCapacity" value="10"/>
    <!-- 对拒绝task的处理策略 -->
    <property name="rejectedExecutionHandler">
        <bean class="java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy"/>
    </property>
</bean>

```



#### 处理流程

1. 当一个任务被提交到线程池时，如果当前运行的线程数小于核心线程数，那么就创建线程来执行任务
2. 如果运行的线程数大于或等于核心线程数，就把task加入到Queue
3. 如果创建的线程数量大于Queue的最大容量，那么创建新线程来执行该任务
4. 如果创建线程导致当前运行的线程数超过最大线程数，就根据饱和策略来拒绝该任务



#### 关闭线程池

调用shutdown或者shutdownNow，两者都不会接受新的任务，调用interrupt方法来中断线程

不同的是shutdownNow会首先将线程池的状态设置为stop，然后尝试停止所有线程，有可能导致任务没有执行完成。

而shutdown则只是加你线程池的状态设置为shutdown，然后中断所有没有执行的任务。



### 11. 线程池都有哪些状态？
![image-20191226155639571](/static/img/thread/线程池的状态.png)

### 12. 线程池中 submit()和 execute()方法有什么区别？



![image-20191226160104206](/static/img/thread/submit.png)

![image-20191226160121503](/static/img/thread/execute.png)



| submit                     | execute          |
| -------------------------- | ---------------- |
| 可以接受Runnable和Callable | 只能接受Runnable |
| 有返回值                   | 无返回值         |



### 13. 在 java 程序中怎么保证多线程的运行安全？

导致原因

- 缓存导致的可见性问题
- 线程切换带来的原子性问题
- 编译优化带来的有序性问题



通过保证线程的原子性、可见性、顺序性来保证线程的运行安全。

1. 原子性

   多线程中的原子性跟MySQL中的原子性，概念类似。即一个操作要么全部执行，要么都不执行，不可以中途暂停，等待CPU调度。

2. 可见性

   可见性是指，当多线程并发访问共享变量的时候，一个线程对 共享变量的修改，其他线程能够立即可见。

   CPU从主内存中读取效率不高，所有现在主流计算机中都会有几级缓存。每个线程读取共享内存变量的时候，都会将该变量加载进对应的CPU缓存中，修改变量后，CPU会立即更新缓存，但是不一定会立即写回到主内存中，此时其他线程访问该共享内存变量的时候，拿不到最新的值。

3. 顺序性

   顺序性是指，程序执行的顺序按照代码的顺序。

   处理器有时候为了整体效率，会对代码的执行顺序做出修改，但是最终执行的结果是一致的。



#### 如何保证线程的原子性

1. 加锁

   在并发编程中，多线程同时并发访问的资源叫做临界资源，当多个线程同时访问对象并要求操作相同资源时，分割了原子操作就有可能出现数据的不一致或数据不完整的情况，为避免这种情况的发生，我们会采取同步机
   制，以确保在某一时刻，方法内只允许有一个线程

   采用 synchronized 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。

   在一个线程获取到资源的时候，阻止其他线程对该资源做出修改。

   就使用同步机制获取互斥锁的情况，进行几点说明：

   1. 如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。
   2. 类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的 synchronized 同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问 synchronized 同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。
   3. 访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。
   4. 持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非 synchronized 代码。当一个线程 A 持有一个对象级别锁（即进入了 synchronized 修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程 B 有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用synchronized 修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让 A 线程运行，A 线程继续持有对象级别锁，当 A 线程退出同步代码时（即释放了对象级别锁），如果 B 线程此时再运行，便会获得该对象级别锁，从而执行 synchronized 中的代码。
   5. 持有对象级别锁的线程会让其他线程阻塞在所有的 synchronized 代码外。例如，在一个类中有三个synchronized 方法 a，b，c，当线程 A 正在执行一个实例对象 M 中的方法 a 时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象 M）中的代码时，便会在所有的 synchronized 方法处阻塞，即在方法 a，b，c 处都要被阻塞，等线程 A 释放掉对象级别锁时，其他的线程才可以去执行方法 a，b 或者 c 中的代码，从而获得该对象级别锁。
   6. 使用 synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj 为对象的引用，如果获取了 obj 对象上的对象级别锁，在并发访问 obj 对象时时，便会在其 synchronized 代码处阻塞等待，直到获取到该 obj对象的对象级别锁。当 obj 为 this 时，便是获取当前对象的对象级别锁。
   7. 类级别锁被特定类的所有示例共享，它用于控制对 static 成员变量以及 static 方法的并发访问。具体用法与对象级别锁相似。
   8. 互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于 synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。

2. CAS(Compare and swap)无锁算法

   CAS包含三个参数，共享变量的原始值A、预期值B、新值C。只有当A、B相等的时候，才会将A的值变为C。

   预期值B等于原始值A，说明共享变量没有被修改过，所以才允许更新新值，这样就保证了原子性。

   如果A不等于B，说明共享变量已经被 其他线程修改过了，当前线程可以放弃此操作。

3. Atomic开头的原子类

4. LOCK

#### 如何保证内存可见性

1. 内存可见性 volatile

   volatile修饰的变量，在被线程读取的时候，都强迫线程去共享内存中读取，当该该变量发生变化的时候，强迫线程将新值写到主内存中。

2. synchronized

   synchronized同步还有一个作用：内存可见性。

   一个线程修改了内容后，其他线程能够看见该变化。

3. LOCK



#### 如何保证程序执行的顺序

happen-before规则

Happens-Before 规则如下：

程序次序规则：在一个线程内，按照程序控制流顺序，书写在前面的操作先行发生于书写在后面的操作
管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始



### 14. 多线程锁的升级原理是什么？
### 

### 15. 什么是死锁？

死锁是一种线程阻塞的现象。
由两个或两个以上线程相互竞争资源导致。
若无外力作用，将一直阻塞下去。

#### 死锁产生条件
1. 互斥条件
   
    线程对于分配到的资源具有排他性，即一个资源只能被一个线程占用，直到该进程释放
    
2. 请求和保持条件

    一个进程因请求被占用而发生阻塞时，对于已经得到的资源保持不放

3. 不剥夺条件

    任何一个资源在没有被进程释放之前，任何其他进程都无法对他剥夺使用

4. 循环等待条件

    当发生死锁时，所等待的进程必定会形成一个环路，造成永久阻塞。

### 16. 怎么防止死锁？

预防:打破上面四个必要条件其中之一即可。

有序资源分配法

银行家算法

### 17. ThreadLocal 是什么？有哪些使用场景？

ThreadLocal是用来存储线程局部变量的一种数据结构。
其内部有一个Map结构来存储变量。
不与其他线程共享其中的变量。隔离性。

其生命周期跟随着线程来的，线程一旦消亡，会被垃回收。


### 18. 说一下 synchronized 底层实现原理？

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步

对于同步方法，反编译后得到ACC_SYNCHRONIZED 标志，对于同步代码块反编译后得到monitorenter和monitorexit指令。

### 
### 19. synchronized 和 volatile 的区别是什么？

| volatile | synchronized |
| --- | --- |
| Volatile本质上是告诉JVM当前变量在工作内存中是不确定的，需要去主内存中读取 | synchronized则是锁定当前变量，只有当前线程可以访问，其他线程被阻塞 |
| volatile仅能是用在变量级别 | synchronized可以作用在变量、方法和类级别 |
| volatile仅能实现变量的修改可见性 | synchronized可以保证变量的修改可见性和原子性 |
| volatile不会造成线程阻塞 | 可以造成线程阻塞 |
| 标记的变量不会被编译器优化 | 可以被编译器优化  |

### 20. synchronized 和 Lock 有什么区别？
### 
### 21. synchronized 和 ReentrantLock 区别是什么？
### 
### 22. 说一下 atomic 的原理？
### 