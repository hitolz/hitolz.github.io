---
layout: post
title: Java面试题收集
tags: [面试]
categories: [面试]
---



[toc]



## 多线程相关

### 1. 并行和并发有什么区别？

并行和串行

通俗来说，并发是一个人在做多件事，并行是多个人同时在做多件事。
只不过并发的时候，CPU高速切换线程，表面上看起来是在同时做多件事。

常说的“多线程”一般是指在同一个进程内，多个线程并发执行。

### 2. 线程和进程的区别？
进程是操作系统资源分配的基本单位，而线程是系统调度的基本单位。
线程是操作系统最小调度单位，是操作系统分配处理器时间资源的基本单位。
进程可以包含多个线程、线程共享进程内存空间

| 进程占有的资源                                               | 线程占有的资源                         |
| ------------------------------------------------------------ | -------------------------------------- |
| 地址空间<br/>全局变量<br/>打开的文件<br/>子进程<br/>信号量<br/>账户信息 | 栈<br />寄存器<br/>状态<br/>程序计数器 |



### 3. 守护线程是什么？
是服务于其他线程的服务线程，一直服务到jvm停止，最典型的应用就是GC线程

其他线程叫做用户线程，就是应用程序里的线程

4种

1. 继承Thread
2. 实现Runnable run
3. 实现Callable call
4. 线程池创建

### 5. 说一下 runnable 和 callable 有什么区别？

相同点：

都是接口，都可以创建线程，都需要 start方法启动线程

不同点：

| runnale        | callable             |
| -------------- | -------------------- |
| 实现run接口    | 实现call接口         |
| 不抛检查型异常 | 会抛异常             |
| java.lang      | java.util.concurrent |
| 不返回执行接口 | 可以返回执行结果     |





### 6. 线程有哪些状态？

创建

就绪：T.start()之后就进入到就绪状态，拿到执行权（锁），等待os调度

运行：os调度

阻塞：T.sleep()、T2.join()、

死亡：run()结束

### 7. sleep() 和 wait() 有什么区别？



| sleep                                                        | wait                                                         |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| Thread类的静态方法，                                         | Object的方法                                                 |
| 不释放资源（锁），其他线程不能抢占资源，sleep时间一到，自动进入就绪状态，等待os调度 | 释放资源（锁），其他线程可以抢占资源，需notify才能进入就绪状态 |
| sleep抛异常                                                  | wait不抛异常                                                 |
| sleep可以在任何地方调用                                      | wait只能在同步方法和同步代码块中使用                         |





### 8. notify()和 notifyAll()有什么区别？
notify唤醒一个线程，

notifyAll唤醒全部线程

### 9. 线程的 run()和 start()有什么区别？
run就是普通方法，

start才会使线程进入就绪状态

### 10. 创建线程池有哪几种方式？
1. 创建数量不定的线程池-`newCachedThreadPool`

   可缓存，可灵活回收空闲线程，若无可回收，则创建新的线程
   
2. 创建数量固定的线程池-`newFixedThreadPool`

   可控制最大并发数，超出的线程会在队列中等待
   
3. 创建单线程的线程池-`newSingleThreadExecutor`

   只会用一个线程来执行任务，按指定顺序（FIFO、LIFO、优先级）执行
   
4. 创建定时执行的线程池-`newScheduledThreadPool`

   支持定时及周期性执行任务



#### 使用`Executors`创建：

```java
// 创建数量不固定的线程池
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
// 创建数量固定的线程池
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
// 创建单线程的线程池
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
// 创建定时执行的线程池
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);

```



#### 使用`Executors`的弊端

1. `newFixedThreadPool`和`newSingleThreadExecutor` 允许的请求队列长度为`Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致OOM
2. `newCachedThreadPool`允许创建的线程数量为`Integer.MAX_VALUE`，可能会大量创建线程，从而导致OOM



通过查看源码，发现底层都是`ThreadPoolExecutor`创建的。

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

参数：

1. `corePoolSize` - 线程池核心池的大小
2. `maximumPoolSize`-线程池的最大线程数
3. `keepAliveTime`-当线程数大于核心池大小的时候，这个时间是多余的空闲线程等待任务的时间，超过这个时间，线程终止
4. `unit` - keepAliveTime 的时间单位
5. `workQueue` - 用来储存等待执行任务的队列，只会存储调用submit或者execute方法的线程
   1. `ArrayBlockingQueue` ：一个由数组结构组成的有界阻塞队列。
   2. `LinkedBlockingQueue` ：一个由链表结构组成的有界阻塞队列。
   3. `PriorityBlockingQueue` ：一个支持优先级排序的无界阻塞队列。
   4. `DelayQueue`： 一个使用优先级队列实现的无界阻塞队列。
   5. `SynchronousQueue`： 一个不存储元素的阻塞队列。
   6. `LinkedTransferQueue`： 一个由链表结构组成的无界阻塞队列。
   7. `LinkedBlockingDeque`： 一个由链表结构组成的双向阻塞队列。
6. `threadFactory` - 线程工厂，创建线程用
7. `handler` - 拒绝策略，由于达到线程边界和容量而阻止执行时要使用的处理程序
   1. `ThreadPoolExecutor.AbortPolicy`: 丢弃任务并抛出`RejectedExecutionException`异常。 (默认)
   2. `ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常。
   3. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试执行任务（重复此程）
   4. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务

#### 使用`ThreadPoolExecutor`创建

```java
// newCachedThreadPool 源码
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
60L, TimeUnit.SECONDS,
new SynchronousQueue<Runnable>());

// newFixedThreadPool 源码
ThreadPoolExecutor threadPoolExecutor1 = new ThreadPoolExecutor(5, 5,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue<Runnable>());


// newSingleThreadExecutor源码
// 封装成FinalizableDelegatedExecutorService
ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(1, 1,
0L, TimeUnit.MILLISECONDS,
new LinkedBlockingQueue<Runnable>());

// newScheduledThreadPool 源码
ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
```



Spring中配置

```xml

<!-- spring thread pool executor -->
<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <!-- 线程池维护线程的最少数量 -->
    <property name="corePoolSize" value="10"/>
    <!-- 允许的空闲时间 -->
    <property name="keepAliveSeconds" value="60"/>
    <!-- 线程池维护线程的最大数量 -->
    <property name="maxPoolSize" value="10"/>
    <!-- 缓存队列 -->
    <property name="queueCapacity" value="10"/>
    <!-- 对拒绝task的处理策略 -->
    <property name="rejectedExecutionHandler">
        <bean class="java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy"/>
    </property>
</bean>

```



#### 使用

- 无返回值的任务使用`execute(Runnable)`
- 有返回值的任务使用`submit(Runnable)`



#### 处理流程

1. 当一个任务被提交到线程池时，如果当前运行的线程数小于核心线程数，那么就创建线程来执行任务
2. 如果运行的线程数大于或等于核心线程数，就把task加入到Queue
3. 如果创建的线程数量大于Queue的最大容量，那么创建新线程来执行该任务
4. 如果创建线程导致当前运行的线程数超过最大线程数，就根据饱和策略来拒绝该任务



#### 关闭线程池

调用shutdown或者shutdownNow，两者都不会接受新的任务，调用interrupt方法来中断线程

不同的是shutdownNow会首先将线程池的状态设置为stop，然后尝试停止所有线程，有可能导致任务没有执行完成。

而shutdown则只是加你线程池的状态设置为shutdown，然后中断所有没有执行的任务。



### 11. 线程池都有哪些状态？
### 
### 12. 线程池中 submit()和 execute()方法有什么区别？
### 
### 13. 在 java 程序中怎么保证多线程的运行安全？
### 
### 14. 多线程锁的升级原理是什么？
### 
### 15. 什么是死锁？
### 
### 16. 怎么防止死锁？
### 

### 17. ThreadLocal 是什么？有哪些使用场景？
### 
### 18. 说一下 synchronized 底层实现原理？
### 
### 19. synchronized 和 volatile 的区别是什么？
### 
### 20. synchronized 和 Lock 有什么区别？
### 
### 21. synchronized 和 ReentrantLock 区别是什么？
### 
### 22. 说一下 atomic 的原理？
### 