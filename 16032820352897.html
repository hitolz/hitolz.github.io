<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    JVM初探 - 非著名Java程序员
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="非著名Java程序员" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                
                <a target="_self" class="navbar-item " href="about1.html">About</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            JVM初探   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/10/21 20:07 下午</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM.html'>JVM</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_JVM.html'>#JVM</a>
                                  
                                    <a class="tag is-link is-light" href='tag_Java.html'>#Java</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2><a id="jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM运行时数据区</h2>
<p><img src="http://hitol.blog.cdn.updev.cn/2020-07-05-15904079187289.jpg" alt="" /></p>
<ul>
<li>
<p>程序计数器</p>
<ul>
<li>是一块很小的内存空间，可以看做是当前线程执行的行号指示器。字节码解释器工作时就是通过改变这个计数器的数值来选取下一条需要执行的字节码指令</li>
<li>线程私有</li>
<li>不会发生OOM</li>
</ul>
</li>
<li>
<p>Java虚拟机栈</p>
<ul>
<li>线程私有</li>
<li>为执行Java方法服务</li>
<li>其工作原理类似于数据结构中的栈--FIFO。每个方法在执行的过程中会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>会发生OOM、StackOverflowError</li>
</ul>
</li>
<li>
<p>本地方法栈</p>
<ul>
<li>线程私有</li>
<li>与虚拟机栈功能类似</li>
<li>为Native方法服务</li>
<li>会发生OOM、StackOverflowError</li>
</ul>
</li>
<li>
<p>Java堆</p>
<ul>
<li>
<p>线程共享</p>
</li>
<li>
<p>几乎所有的对象实例都在堆中分配。</p>
</li>
<li>
<p>逃逸分析、标量替换--&gt;栈上分配</p>
</li>
<li>
<p><img src="http://hitol.blog.cdn.updev.cn/2020-07-05-15904091934707.jpg" alt="" /></p>
</li>
<li>
<p>新生代:老年代 = 1:2</p>
</li>
<li>
<p>Eden:S0:S1 = 8:1:1</p>
</li>
</ul>
</li>
<li>
<p>方法区</p>
<ul>
<li>线程共享</li>
<li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</li>
<li>运行时常量池：用于存放编译期生成的各种字面量和符号引用</li>
<li>会出现OOM</li>
</ul>
</li>
</ul>
<h2><a id="%E8%BE%A3%E9%B8%A1%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BE%A3%E9%B8%A1%E5%9B%9E%E6%94%B6%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>辣鸡回收算法与辣鸡回收器</h2>
<p>辣鸡回收需要做的3件事情</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>上面JVM运行时数据区中线程私有变量（本地方法栈、JVM虚拟机栈、程序计数器）会随着方法执行的完成而自动释放内存，所以这部分的内存不需要考虑回收。需要考虑回收的内存主要就是堆内存与方法区，只有在程序运行的时候才知道会创建哪些对象，哪些需要回收。</p>
<p>--<br />
判断对象是否存活</p>
<ol>
<li>
<p>程序计数器</p>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就+1，当引用失效时，计数器的值-1.</p>
<p>但是主流的Java虚拟机里面并没有使用这种方式，最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
</li>
<li>
<p>可达性分析(GC Roots)</p>
<p>使用最多的是这种方式。<br />
这种算法的思路就是，选择一个根节点，从这个节点往下搜索，搜索过程中走过的路径称为引用链，当一个对象到根节点没有引用链存在时，也就是不可达，这种对象就是辣鸡对象。<br />
哪些对象可以作为GC Roots</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ul>
</li>
<li>
<p>引用的类型</p>
<ul>
<li>
<p>强引用：</p>
<ul>
<li>new出来的对象都是强引用对象，在没有指定该对象=null，不会被回收。</li>
</ul>
<pre><code class="language-plain_text">Object obj =new Object();  // 强引用
</code></pre>
</li>
</ul>
<p>obj = null;//这时候为垃圾回收器回收这个对象，至于什么时候回收，取决于垃圾回收器的算法</p>
<pre><code class="language-plain_text">     
 - 软引用：
     - SoftReference
     - 当内存不够用的时候会回收。
     - 适合做缓存。

     
     ```
     String value = new String(“sy”);
</code></pre>
</li>
</ol>
<p>SoftReference sfRefer = new SoftReference (value );<br />
sfRefer .get();//可以获得引用对象值<br />
```<br />
- 弱引用<br />
- WeakReference<br />
- 只要发生GC就会回收。<br />
- 适合加载的时候初始化用。<br />
- ThreadLocal中有使用。</p>
<pre><code class="language-plain_text">    ```
    String value = new String(“sy”);
    WeakReference weakRefer = new WeakReference(value );
    System.gc();
    weakRefer.get();//null
    ```
    
- 虚引用
    - 作用：管理堆外内存。
    - NIO中 DirectByreBuffer
</code></pre>
<ol start="4">
<li>
<p>对象的自我拯救-二次标记</p>
<ul>
<li>当一个对象被标记为辣鸡后并不会立马被回收掉。</li>
<li>第一次经过可达性分析后发现该对象是辣鸡对象，会被第一次标记并且进行一次筛选，筛选的条件是此对象时候有必要执行<code>finalize</code>方法，</li>
<li>如果该对象需要执行finallize方法，那么这个对象会被放置在一个F-Queue的队列中，稍后GC将会对队列中的对象信心小规模的二次标记。</li>
<li>如果对象在执行finalize过程中，与GC Roots建立联系了，那么这个对象就不会被回收，反之就会被回收了。</li>
</ul>
</li>
<li>
<p>回收方法区<br />
永久代主要回收两类对象：废弃常量和无用的类。<br />
废弃常量好理解，没有任何对象引用常量池中的某个变量，这个变量就是废弃常量。<br />
如何判断一个类是无用的类</p>
<ul>
<li>该类的所有实例都已经被回收掉</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ol>
<h3><a id="%E8%BE%A3%E9%B8%A1%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>辣鸡回收算法</h3>
<ol>
<li>
<p>标记-清除算法<br />
当对象被标记为辣鸡后，直接清理掉。<br />
效率不高、容易产生内存碎片</p>
</li>
<li>
<p>标记-整理算法<br />
被标记为辣鸡的对象回收之后，整理内存空间。</p>
</li>
<li>
<p>复制算法<br />
将内存分为大小相等的两块，每次内存分配的时候只使用其中的一块，当这块内存满了只有，将存活对象复制到另一块内存空间中，然后整块清理。<br />
实现简单、运行高效<br />
但是浪费一半的内存。</p>
</li>
<li>
<p>分代收集算法<br />
目前使用这种算法。</p>
</li>
</ol>
<p>新生代中发生GC -- minor gc</p>
<p>minor GC test</p>
<pre><code class="language-plain_text">public class HeapTest {

	private byte[] bytes = new byte[1024*100];

	public static void main(String[] args) throws InterruptedException {
		List&lt;HeapTest&gt; list = new ArrayList&lt;&gt;();
		while (true) {
			System.out.println(111);
			list.add(new HeapTest());
			Thread.sleep(10);
		}
	}
}
</code></pre>
<p><img src="http://hitol.blog.cdn.updev.cn/2020-07-05-minor-gc.gif" alt="minor-g" /></p>
<p>这图是上面的代码运行时的gc情况。</p>
<p><img src="http://hitol.blog.cdn.updev.cn/2020-07-05-15904106385761.jpg" alt="" /></p>
<p>从图中可以得出结论，新生成的对象都是在Eden区，当Eden区满了后，会执行gc回收，将Eden区与S0区中的存活对象拷贝到S1，并清空Eden、S0，存活对象年龄+1；<br />
当新生对象又一次将Eden区填满后，会将Eden区、S1中的存活对象拷贝到S0，并清空S1，存活对象年龄+1；<br />
当存活对象的年龄达到15后，会被认为是老不死对象，挪到老年代内存中。<br />
新生代中的GC 叫做minor GC。<br />
老年代内存占满后进行的GC就是FULL GC。<br />
minor GC正常情况下可以回收70--95%的空间。</p>
<p>--<br />
对象进入老年代的情况：</p>
<ul>
<li>长期存活的对象进入老年代
<ul>
<li>对象年龄达到15后</li>
<li>markword中2字节表示</li>
</ul>
</li>
<li>内存担保机制
<ul>
<li>当Eden区的内存不足以容纳新生成的对象的时候，新生成的对象会直接进入老年代</li>
</ul>
</li>
<li>动态年龄判断(大对象直接进入老年代)
<ul>
<li>新生成的对象的内存大于Eden区内存的50%会直接进入老年代</li>
</ul>
</li>
</ul>
<p>JVM调优的目的：减少FULL GC</p>
<p>--</p>
<h3><a id="%E8%BE%A3%E9%B8%A1%E6%94%B6%E9%9B%86%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>辣鸡收集器</h3>
<p><img src="http://hitol.blog.cdn.updev.cn/2020-07-05-15904221132976.jpg" alt="" style="width:501px;" /></p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
<li>Serial Old</li>
<li>Parallel Old</li>
<li>CMS</li>
<li>G1</li>
</ul>
<p>-XX:+UseParallelGC</p>
<p>--<br />
TODO<br />
JVM调优参数<br />
JDK工具<br />
安全点与安全区域<br />
STW<br />
各种垃圾收集器<br />
逃逸分析与标量替换</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
