<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    Java并发机制的底层实现原理 - 非著名Java程序员
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="非著名Java程序员" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                
                <a target="_self" class="navbar-item " href="about1.html">About</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            Java并发机制的底层实现原理   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/11/25 23:11 下午</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.html'>Java并发编程的艺术</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <div class="mweb_toc"><ul>
<li><a href="#volatile%E7%9A%84%E5%BA%94%E7%94%A8">volatile的应用</a>
<ul>
<li><a href="#volatile%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0">volatile的定义与实现</a></li>
<li><a href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F">禁止指令重排序</a></li>
<li><a href="#volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96">volatile的使用优化</a></li>
</ul>
</li>
<li><a href="#synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8">synchronized的实现原理与应用</a>
<ul>
<li><a href="#java%E5%AF%B9%E8%B1%A1%E5%A4%B4">Java对象头</a></li>
<li><a href="#%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94">锁升级与对比</a>
<ul>
<li><a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>
<ul>
<li><a href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80">偏向锁的撤销</a></li>
</ul>
</li>
<li><a href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a></li>
</ul>
</li>
<li><a href="#%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9">锁的优点与缺点</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">原子操作的实现原理</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E9%94%81">总线锁</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E9%94%81">缓存锁</a></li>
<li><a href="#java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">Java如何实现原子操作</a>
<ul>
<li><a href="#%E8%87%AA%E6%97%8Bcas">自旋CAS</a></li>
<li><a href="#%E9%94%81%E6%9C%BA%E5%88%B6">锁机制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2><a id="volatile%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>volatile的应用</h2>
<p>volatile是轻量级的synchronized，在并发编程中2个作用：</p>
<ol>
<li>保证了共享变量的可见性</li>
<li>禁止指令重排序</li>
</ol>
<p>可见性的意思是当一个线程修改了一个共享变量时，另一个线程能读到修改的这个值。</p>
<h3><a id="volatile%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>volatile的定义与实现</h3>
<p>定义如下：<br />
Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>有volatile变量修饰的共享变量进行写操作的时候会多出汇编代码，lock。</p>
<p>lock前缀的指令在多核处理器下引发了两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>原理：<br />
缓存一致性协议 MESI<br />
总线嗅探</p>
<h3><a id="%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>禁止指令重排序</h3>
<hr />
<p><a href="https://tech.meituan.com/2014/09/23/java-memory-reordering.html">https://tech.meituan.com/2014/09/23/java-memory-reordering.html</a></p>
<h3><a id="volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>volatile的使用优化</h3>
<p>缓存行是缓存中可以分配的最小存储单位，缓存行64字节。</p>
<p>采用追加字节的方式，使生成的对象占用64字节。</p>
<p>以下有个优化的例子，</p>
<p>A类通过声明7个没有用的long类型变量，加上一个有用的long类型变量x，总共8个long类型变量，共64字节，或者是14个引用类型，引用类型占4字节，加一个long类型变量x，也是64字节。</p>
<p>然后启动两个线程，每个线程对x累加10000000次，x被声明为volatile，每次修改都会对其他线程可见，</p>
<p>把追加的字节删除之后在测试，用时差异比较明显。</p>
<p>追加字节后测试时间大概60几毫秒，<br />
不追加字节测试时间大概200多毫秒。</p>
<details>
<summary>展开查看</summary>
<pre><code class="language-java">public class CacheLineTest {

	static class A{
		/**
		 * 采用追加字节的方式，生成对象A占用64字节，正好是缓存行的容量
		 * 一个long类型8字节。
		 * private long a1,a2,a3,a4,a5,a6,a7;
		 * 一个引用类型4字节。
		 * private Object a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae;
		 */
		private long a1,a2,a3,a4,a5,a6,a7;
		private volatile long x = 0;

		public long getX() {
			return x;
		}

		public void setX(long x) {
			this.x = x;
		}
	}

	public static long test() throws InterruptedException {
		A a1 = new A();
		A a2 = new A();

		Thread t1 = new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i &lt; 10000000; i++) {
					a1.setX(i);
				}
			}
		});


		Thread t2 = new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i &lt; 10000000; i++) {
					a2.setX(i);
				}
			}
		});

		long start = System.currentTimeMillis();

		t1.start();
		t2.start();

		t1.join();
		t2.join();

		long end = System.currentTimeMillis();

		long diff = end - start;
		System.out.println(&quot;花费时间: &quot; + diff);
		return diff;
	}


	public static void main(String[] args) throws InterruptedException {
		test();
	}

}
</code></pre>
</details>
<h2><a id="synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>synchronized的实现原理与应用</h2>
<p>Java中的每一个对象都可以被作为锁。具体表现为以下3种形式：</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是synchronized括号里配置的对象。</li>
</ol>
<p>代码块同步是使用monitorenter和monitorexit指令实现的。</p>
<p>monitorenter是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。任何对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。</p>
<h3><a id="java%E5%AF%B9%E8%B1%A1%E5%A4%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java对象头</h3>
<p>synchronized用的锁是存在Java对象头里的。</p>
<p>Java对象头里的Mark Word里默认存储对象的 HashCode、分代年龄和锁标记位。</p>
<p>64位虚拟机下，Mark Word是64bit大小，其存储结构为：<br />
<img src="http://hitol.blog.cdn.updev.cn/16066385450384.jpg" alt="" style="width:835px;" /></p>
<h3><a id="%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>锁升级与对比</h3>
<p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了 “偏向锁” 和 “轻量级锁”。</p>
<p>锁一共有4中状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态随着竞争情况逐渐升级。</p>
<p>锁可以升级但不能降级。目的是为了提高获得锁和释放锁的效率。</p>
<h4><a id="%E5%81%8F%E5%90%91%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>偏向锁</h4>
<p>Java虚拟机的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让这种线程获得锁的代价更低而引入了偏向锁。</p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</p>
<h5><a id="%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>偏向锁的撤销</h5>
<p>当出现竞争的情况，偏向锁会撤销，并升级为轻量级锁。</p>
<p>偏向锁的撤销需要等待全局安全点(safe point，通常会STW)，会首先暂停拥有  偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，占中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p><strong>偏向锁加锁就是将锁的对象头中的线程ID指向自己，使这个锁偏向于自己。<br />
偏向锁的撤销就是将锁对象的对象头中的线程ID设置为空。</strong></p>
<h4><a id="%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>轻量级锁</h4>
<p>加锁</p>
<p>线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p>解锁</p>
<p>轻量级解锁时，会使用原子的CAS操作将当前线程的栈帧中的对象头替换回到锁对象的对象头，如果成功，则表示没有竞争发生，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p>自旋会消耗CPU，所以一旦锁升级为重量级锁就不会再恢复到轻量级锁状态。</p>
<h3><a id="%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>锁的优点与缺点</h3>
<p><img src="http://hitol.blog.cdn.updev.cn/16066410640545.jpg" alt="" style="width:1352px;" /></p>
<h2><a id="%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原子操作的实现原理</h2>
<h3><a id="%E6%80%BB%E7%BA%BF%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总线锁</h3>
<p>所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，该处理器可以独占共享内存。</p>
<p>总线锁开销比较大。</p>
<h3><a id="%E7%BC%93%E5%AD%98%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缓存锁</h3>
<p>缓存一致性协议，MESI。</p>
<h3><a id="java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java如何实现原子操作</h3>
<h4><a id="%E8%87%AA%E6%97%8Bcas" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自旋CAS</h4>
<p>JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现的。</p>
<p>CAS操作带来的问题：</p>
<ol>
<li>
<p>ABA问题</p>
<p>当一个值A，变成B，又变为A，这时候使用CAS进行检查时会发现它的值没有发生变化，但实际上是发生变化的。</p>
<p>ABA问题的解决思路就是使用版本号或者时间戳。</p>
</li>
<li>
<p>循环时间长开销大</p>
</li>
<li>
<p>只能保证一个共享变量的原子操作</p>
</li>
</ol>
<h4><a id="%E9%94%81%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>锁机制</h4>
<p>偏向锁、轻量级锁和互斥锁。</p>
<p>除了偏向锁，JVM实现锁的方式都用了自旋CAS。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
